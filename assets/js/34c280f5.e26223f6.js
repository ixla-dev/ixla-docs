"use strict";(self.webpackChunkixla_docs=self.webpackChunkixla_docs||[]).push([[5242],{7589:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});var r=s(4848),o=s(8453);const a={ignore:!0,sidebar_class_name:"hidden",id:"webhooks-integration",title:"Webhooks Integration \ud83c\udf10"},i=void 0,t={id:"webhooks-integration",title:"Webhooks Integration \ud83c\udf10",description:"Introduction",source:"@site/docs/webhooks-integration.md",sourceDirName:".",slug:"/webhooks-integration",permalink:"/ixla-docs/docs/webhooks-integration",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{ignore:!0,sidebar_class_name:"hidden",id:"webhooks-integration",title:"Webhooks Integration \ud83c\udf10"},sidebar:"defaultSidebar",previous:{title:"Start Issuance",permalink:"/ixla-docs/docs/setup-and-integration/start-issuance"}},d={},l=[{value:"Introduction",id:"introduction",level:3},{value:"External Process Messages",id:"external-process-messages",level:4},{value:"Examples",id:"examples",level:5},{value:"Recoverable Error Messages",id:"recoverable-error-messages",level:4},{value:"Examples",id:"examples-1",level:5},{value:"Diagnostic Messages",id:"diagnostic-messages",level:4},{value:"Error Codes &amp; Job Statuses",id:"error-codes--job-statuses",level:4},{value:"Sequence Diagrams",id:"sequence-diagrams",level:4},{value:"Examples",id:"examples-2",level:4},{value:"Serialization",id:"serialization",level:4},{value:"Webhook Messages Types",id:"webhook-messages-types",level:3},{value:"MessageType",id:"messagetype",level:4},{value:"Common Properties",id:"common-properties",level:4},{value:"Job Statuses and Error Codes",id:"job-statuses-and-error-codes",level:4},{value:"JobStatus",id:"jobstatus",level:5},{value:"ErrorCodes",id:"errorcodes",level:5},{value:"EncoderLoadedMessage (Suspends Workflow)",id:"encoderloadedmessage-suspends-workflow",level:4},{value:"OcrExecutedMessage (Suspends Workflow)",id:"ocrexecutedmessage-suspends-workflow",level:4},{value:"WorkflowSchedulerProcessSuspendedMessage (Suspends Workflow)",id:"workflowschedulerprocesssuspendedmessage-suspends-workflow",level:4},{value:"WebhookReceiverHealthCheckMessage",id:"webhookreceiverhealthcheckmessage",level:4},{value:"WorkflowCancelledMessage",id:"workflowcancelledmessage",level:4},{value:"WorkflowCompletedMessage",id:"workflowcompletedmessage",level:4},{value:"WorkflowFaultedMessage",id:"workflowfaultedmessage",level:4},{value:"WorkflowSchedulerStartedMessage",id:"workflowschedulerstartedmessage",level:4},{value:"WorkflowSchedulerStoppedMessage",id:"workflowschedulerstoppedmessage",level:4},{value:"ExternalProcessCompletedMessage",id:"externalprocesscompletedmessage",level:4},{value:"Sequence Diagrams",id:"sequence-diagrams-1",level:3},{value:"Issuance Startup Sequence",id:"issuance-startup-sequence",level:4},{value:"Chip Encoding Sequence",id:"chip-encoding-sequence",level:4},{value:"Examples",id:"examples-3",level:3},{value:"Handling EncoderLoaded Message",id:"handling-encoderloaded-message",level:4},{value:"Resuming / Rejecting",id:"resuming--rejecting",level:5},{value:"Handling SchedulerProcessSuspended Message",id:"handling-schedulerprocesssuspended-message",level:4},{value:"Feeder empty example",id:"feeder-empty-example",level:5},{value:"Resuming suspended workflows",id:"resuming-suspended-workflows",level:5},{value:"Graceful stop",id:"graceful-stop",level:5}];function c(e){const n={a:"a",code:"code",em:"em",h3:"h3",h4:"h4",h5:"h5",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h3,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"Webhooks"})," are enabled in the ",(0,r.jsx)(n.code,{children:"JobTemplate"}),"'s configuration. AIDA publishes notifications when relevant events occur during\nissuance.\n",(0,r.jsx)(n.code,{children:"Webhooks"})," are ",(0,r.jsx)(n.code,{children:"JSON Encoded"})," and transmitted as ",(0,r.jsx)(n.code,{children:"HTTP POST"})," quests."]}),"\n",(0,r.jsxs)(n.p,{children:["For operations like ",(0,r.jsx)(n.strong,{children:"Chip Encoding, Readback and OCR"})," webhooks are mandatory. The receiving application must respond to webhook requests\nwith a successful ",(0,r.jsx)(n.code,{children:"HTTP Status Code (2xx)"})]}),"\n",(0,r.jsx)(n.p,{children:"We can separate message in 3 categories:"}),"\n",(0,r.jsx)(n.h4,{id:"external-process-messages",children:"External Process Messages"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#encoderloadedmessage-suspends-workflow",children:"EncoderLoadedMessage"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#ocrexecutedmessage-suspends-workflow",children:"OcrExecutedMessage"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["These messages indicate that AIDA suspended the execution of a Job and it is waiting an external operation to complete (OCR output validation, Chip Encoding reading/writing). The receiving application can singnal the completion of the operation by sending an ",(0,r.jsx)(n.a,{href:"#externalprocesscompletedmessage",children:"ExternalProcessCompletedMessage"})," to the ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"SignalExternalProcessCompleted"})})," API endpoint."]}),"\n",(0,r.jsx)(n.h5,{id:"examples",children:"Examples"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#handling-encoderloaded-message",children:"Handling EncoderLoaded Message"})}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"recoverable-error-messages",children:"Recoverable Error Messages"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#workflowschedulerprocesssuspendedmessage-suspends-workflow",children:"WorkflowSchedulerProcessSuspendedMessage"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"These messages indicate that issuance was suspended and manual intervention is required."}),"\n",(0,r.jsx)(n.p,{children:"Recoverable error statuses are:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Input feeder empty"}),"\n",(0,r.jsx)(n.li,{children:"Open Interlock"}),"\n",(0,r.jsx)(n.li,{children:"Card Jam (Only in box systems)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The controlling application can:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Tell AIDA to resume issuance and retry"}),"\n",(0,r.jsx)(n.li,{children:"Stop issuance"}),"\n"]}),"\n",(0,r.jsx)(n.h5,{id:"examples-1",children:"Examples"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#handling-schedulerprocesssuspended-message",children:"Handling SchedulerProcessSuspended Message"})}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"diagnostic-messages",children:"Diagnostic Messages"}),"\n",(0,r.jsxs)(n.p,{children:["All other messages require the receiving application to respond with a ",(0,r.jsx)(n.code,{children:"2xx"})," status code, indicating that the message was received."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#webhookreceiverhealthcheckmessage",children:"WebhooksReceiverHealthCheck"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#workflowschedulerstartedmessage",children:"WorkflowSchedulerStarted"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#workflowschedulerstoppedmessage",children:"WorkflowSchedulerStopped"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#workflowfaultedmessage",children:"WorkflowStarted"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#workflowcancelledmessage",children:"WorkflowCanceled"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#workflowcompletedmessage",children:"WorkflowCompleted"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#workflowfaultedmessage",children:"WorkflowFaulted"})}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"error-codes--job-statuses",children:"Error Codes & Job Statuses"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#jobstatus",children:"Job Statuses"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#errorcodes",children:"Error Codes"})}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"sequence-diagrams",children:"Sequence Diagrams"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#issuance-startup-sequence",children:"Starting Issuance"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#chip-encoding-sequence",children:"Chip Encoding"})}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"examples-2",children:"Examples"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#handling-encoderloaded-message",children:"Handling EncoderLoaded Message"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#handling-schedulerprocesssuspended-message",children:"Handling SchedulerSuspended Message"})}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"serialization",children:"Serialization"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Enums"})," are serialized as strings, and properties are serialized in ",(0,r.jsx)(n.code,{children:"camelCase"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"webhook-messages-types",children:"Webhook Messages Types"}),"\n",(0,r.jsx)(n.p,{children:"Below there's a listing of all webhook messages."}),"\n",(0,r.jsx)(n.h4,{id:"messagetype",children:"MessageType"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public enum MessageType\n{\n    // default value, webhook receivers should never get this\n    Unknown,\n    // encdoer loaded message (sent when a card is placed in one of the encoders)\n    EncoderLoaded,\n    // ocr executed message (sent at the end of an ocr reading)\n    OcrExecuted,\n    // workflow started (sent when a new job is started)\n    WorkflowStarted,\n    // workflow completed (sent when a job is completed)\n    WorkflowCompleted,\n    // workflow faulted (sent when a card is rejected)\n    WorkflowFaulted,\n    // workflow cancelled (sent when a job is cancelled)\n    WorkflowCancelled,\n\n    // -- deprecated -- \n    // The feeder empty message was replaced by WorkflowSchedulerSuspended\n    // with error code = FeederEmpty\n    FeederEmpty,\n    // workflwo scheduler started message (if webhooks are enabled, it is sent when \n    // AIDA beings polling the database for jobs to process)\n    WorkflowSchedulerStarted,\n    // workflow scheduler stopped message (issuance stopped)\n    WorkflowSchedulerStopped,\n    // workflow scheduler suspended (issuance suspedned)\n    WorkflowSchedulerSuspended,\n    // healtcheck message\n    HealthCheck\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"common-properties",children:"Common Properties"}),"\n",(0,r.jsxs)(n.p,{children:["All webhook messages inherit from ",(0,r.jsx)(n.code,{children:"WorkflowMessage"})," which has the following properties"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// All webhook messages extends from WorkflowMessage\nabstract class WorkflowMessage \n{\n    // identifiers to recongnize which machine is sending the message\n    // these are usefull if the receiving application control more than one \n    // machine\n    public string MachineName;\n    public string MachineSerial;\n    public string HostName;\n\n    // The value of the job_id field in the Data Exchange Table\n    public string JobId;\n    // The value ofr the batch_id field\n    public string BatchId;\n    // The value ofr the correlation_id field\n    public string CorrelationId;\n\n    // unique identifier for the webhook message\n    public string MessageId;\n\n    // identifier of the process for this job. These field is required to resume jobs\n    // when using the Signal\n    public string WorkflowInstanceId;\n\n    // the name of the workflow definition used for the job's workflow instance\n    public string WorkflowInstanceName;\n    \n    // Enum that identifies the message kind \n    public MessageType MessageType;\n\n    // The current status of the job \n    public JobStatus JobStatus;\n\n    // An error code that signals the reason why the job has the current JobStatus\n    public JobErrorCodes ErrorCode; \n\n    // The same value as the `AdditionalMetadata` value sent to AIDA when starting \n    // issuance. See `StartWorkflowScheduler` API endpoint documentation for more \n    // information \n    public Dictionary<string, object?> AdditionalMetadata; \n    \n    // If `true` all perso operations where executed on the card. \n    // This is usefull if all operations where executed but the workflow fails. \n    // Example: \n    // Job template with `Chip Encoding` and `Laser Engraving` enabled. \n    // - Chip Encoding executes without problems\n    // - Laser Engraving executes without problems\n    // - The crad gets stuck in the machine when AIDA is trying to move it from the \n    // laser position to the output stacker. \n    // In this case the job will enter the `Faulted` state with error code `CardJam` and \n    // AIDA will publish the `WorkflowFaultedMessage` with `ErrorCode` = `CardJam` and \n    // `DocumentProduced` = True\n    public bool DocumentProduced;\n\n    // Set to `true` when any of the operations executed on the card are destructive: \n    // - Laser Engraving\n    // - Chip Encoding \n    // - Magnetic stripe write\n    public bool DestructiveOperationExecuted;\n\n    // If a critical error occurs (CardJam is one of these), AIDA will cancel the execution \n    // of jobs that cannot recover from the current error state. \n    // The SourceJobInstanceId contains the Identifier of the job that triggered the error\n    // in first place \n    public string SourceJobInstanceId;\n\n    // Contains the `CLR` type name and it is used to support polymorphism \n    // during serialization/deserialization\n    public string Discriminator;\n\n} \n"})}),"\n",(0,r.jsx)(n.h4,{id:"job-statuses-and-error-codes",children:"Job Statuses and Error Codes"}),"\n",(0,r.jsxs)(n.p,{children:["Job statuses are used to indicate if the job is currently running or not. Error codes are used to signal the reason why ",(0,r.jsx)(n.code,{children:"Jobs"})," are in a specific ",(0,r.jsx)(n.code,{children:"JobStatus"}),";"]}),"\n",(0,r.jsx)(n.h5,{id:"jobstatus",children:"JobStatus"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public enum JobStatus\n{\n    None,\n\n    /// <summary>\n    /// Inserted in the data exchange table but not yet picked up by the workflow scheduler\n    /// </summary>\n    Waiting,\n\n    /// <summary>\n    /// The workflow engine is about to executing (or is executing) the first \n    /// activity. we consider the job\n    /// Running once we know that the card was moved from the feeder. \n    /// </summary>\n    Starting,\n   \n    /// <summary>\n    /// We are resuming the workflow after suspension. \n    /// This happens when we receive a notification from\n    /// a webhooks receiver. Workflows are suspended \n    /// when we need to wait for external systems to perform\n    /// operations on the document (chip encoding, OCR validation etc, feeder empty). \n    /// </summary>\n    Resuming,\n\n    /// <summary>\n    /// workflow created and started\n    /// </summary>\n    Running,\n\n    /// <summary>\n    /// workflow completed correctly \n    /// </summary>\n    Completed,\n\n    ///<summary>\n    /// workflow was manually cancelled\n    /// </summary>\n    Cancelled,\n\n    /// <summary>\n    /// Workflow waiting for an external signal to resume\n    /// </summary>\n    Suspended,\n\n    /// <summary>\n    /// rejected\n    /// </summary>\n    Rejected,\n\n    /// <summary>\n    /// faulted\n    /// </summary>\n    Faulted,\n}\n"})}),"\n",(0,r.jsx)(n.h5,{id:"errorcodes",children:"ErrorCodes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'public enum JobErrorCodes\n{\n    /// <summary>\n    /// No errors so far\n    /// </summary>\n    NoErrors,\n\n    /// <summary>\n    /// Workflow scheduler stopped from API\n    /// </summary>\n    ManualStop,\n\n    /// <summary>\n    /// Generic Error\n    /// </summary>\n    GenericError,\n\n    /// <summary>\n    /// The firmware returned CardJam during a move card\n    /// </summary>\n    CardJam,\n\n    /// <summary>\n    /// SCAPS returned an error code during mark\n    /// </summary>\n    MarkLayoutFailed,\n\n    /// <summary>\n    /// Open interlocks\n    /// </summary>\n    OpenInterlock,\n\n    /// <summary>\n    /// The layout that is being marked lays outside the operable area of the laser \n    /// modules scan head\n    /// </summary>\n    MarkErrorLayoutOutOfBounds,\n\n    /// <summary>\n    /// The entity list that needs to be marked is empty\n    /// </summary>\n    MarkErrorEntitySelectionEmpty,\n\n    /// <summary>\n    /// Another mark process is being executed \n    /// </summary>\n    MarkErrorMarkAlreadyExecuting,\n\n    /// <summary>\n    /// External process signaled completion with outcome "Faulted"\n    /// </summary>\n    ChipPersonalizationFailed,\n\n    /// <summary>\n    /// Mag stripe encoder nack while reading \n    /// </summary>\n    MagStripeReadFailed,\n\n    /// <summary>\n    /// Mag stripe encoder nack while writing\n    /// </summary>\n    MagStripeWriteFailed,\n\n    /// <summary>\n    /// External validation signaled completion with outcome "Faulted"\n    /// </summary>\n    OcrUnexpectedResult,\n\n    /// <summary>\n    /// Image acquisition failed when trying to perform ocr\n    /// </summary>\n    OcrFailedToAcquireImage,\n\n    /// <summary>\n    /// OCR algorithm execution failed. This might happen if configuration or parameters\n    /// are invalid\n    /// </summary>\n    OcrFailedToExecuteAlgorithm,\n\n    /// <summary>\n    /// We could not find the configured pattern. This might indicate that the image\n    /// acquired is not good or the card is not in the correct position\n    /// </summary>\n    AutoPosFailedToMatchPattern,\n\n    /// <summary>\n    /// The webhook receiver did not send an HTTP Response within the configured timeout\n    /// </summary>\n    WebhookAckTimeout,\n\n    /// <summary>\n    /// Cannot reach the webhooks receiver\n    /// </summary>\n    WebhooksServerUnreachable,\n\n    /// <summary>\n    /// Input feeder is empty. \n    /// </summary>\n    FeederEmpty,\n\n    /// <summary>\n    /// During startup AIDA checks if there are workflows in inconsistent states \n    /// (eg. Running, Suspended). \n    /// If it finds any, it sets the status to `Cancelled` with this error code. \n    /// Workflows in inconsistent states if the machine is shutdown during issuance \n    /// </summary>\n    CancelledOnStartup,\n\n    /// <summary>\n    /// We received the ExternalProcessCompletedMessage \n    /// with value `Faulted` after `OcrValidation`\n    /// </summary>\n    OcrExternalValidationKo,\n\n    /// <summary>\n    /// Happens if the CCI Api returns 0 when loading the sjf file\n    /// </summary>\n    FailedToLoadJobTemplate,\n\n    /// <summary>\n    /// This status is set if a card needs to be moved but the transport is in error\n    /// state. Might happen in a situation like the following:\n    ///\n    /// - card jam occurs while moving card `N`\n    /// - card `N+1` needs to be moved but the status is not in `Ready` state \n    /// </summary>\n    InvalidTransportStatus,\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"encoderloadedmessage-suspends-workflow",children:"EncoderLoadedMessage (Suspends Workflow)"}),"\n",(0,r.jsx)(n.p,{children:"Sent by the machine when a card is placed in one of the available encoding stations."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"/// Sent when the machine places a card in one of the encoding stations\npublic class EncoderLoadedMessage : WorkflowMessage\n{\n\n    public override MessageType Type => MessageType.EncoderLoaded;\n    // String identifier for the encoder (set in AIDA server configuration)\n    public String EncoderId;\n    // Index of the encoder \n    // (0 based index for the encoder, indices increase from right to left)\n    public int EncoderIndex;\n    // URL that needs to be invoked to signal AIDA\n    // when the encoding process is finished\n    // You can ignore this parameter and just invoke the \n    // SignalExternalProcessCompleted API Endpoint\n    public String CallbackUrl;\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"ocrexecutedmessage-suspends-workflow",children:"OcrExecutedMessage (Suspends Workflow)"}),"\n",(0,r.jsxs)(n.p,{children:["At the end of an OCR reading, the machine sends ",(0,r.jsx)(n.code,{children:"OcrExecutedMessage"})," containing the\nresult of the readings."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class OcrExecutedMessage : WorkflowMessage\n{\n    public MessageType MessageType => MessageType.OcrExecuted;\n    // The result of the OCR inspections ran by the machine\n    public Array<RuntimeOcrInspectionResult> Results;\n}\n\npublic class RuntimeOcrInspectionResult\n{\n    // the name of the inspection used to execute the OCR reading\n    // this is part of the job template's configuration\n    public String InspectionName;\n    // The reuslt of the OCR Reading\n    public OCRResult OcrResult;\n}\n\npublic class OCRResult\n{\n\n    // UTF8 text returned by the OCR Engine\n    public String Text;\n    // Mean confidence of the recongnized text\n    // These can be used to decide if the r\n    public float MeanConfidence;\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"workflowschedulerprocesssuspendedmessage-suspends-workflow",children:"WorkflowSchedulerProcessSuspendedMessage (Suspends Workflow)"}),"\n",(0,r.jsx)(n.p,{children:"This message can be published for 2 reasons:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["The Input Feeder Is empty (",(0,r.jsx)(n.code,{children:"ErrorCode = FeederEmpty"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["The machine detected an open interlock ",(0,r.jsx)(n.strong,{children:"before"})," engraving the card. The ",(0,r.jsx)(n.strong,{children:"before"})," is very important here, if the machine detects open interlocks ",(0,r.jsx)(n.strong,{children:"during"})," laser engraving the card will be rejected, since opening an interlock automatically disables the laser source."]}),"\n",(0,r.jsxs)(n.li,{children:["A card jam occurred and can be recovered (",(0,r.jsx)(n.code,{children:"ErrorCode = CardJam"})," Only for BOX systems, desktop machines cannot recover from ",(0,r.jsx)(n.code,{children:"CARD_JAM"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class WorkflowSchedulerProcessSuspendedMessage : WorkflowMessage \n{\n    public MessageType MessageType => MessageType.WorkflowSchedulerSuspended;\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"webhookreceiverhealthcheckmessage",children:"WebhookReceiverHealthCheckMessage"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"WebhookReceiverHealthCheckMessage"})," is used by AIDA to test ",(0,r.jsx)(n.code,{children:"WebhooksReceiver"})," availability, it is sent:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["When users click the ",(0,r.jsx)(n.code,{children:"Test"})," button in the ",(0,r.jsx)(n.code,{children:"Webapp"})]}),"\n",(0,r.jsxs)(n.li,{children:["During ",(0,r.jsx)(n.code,{children:"Issuance graceful stop"})]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class WebhookReceiverHealthCheckMessage : WorkflowMessage \n{\n    public MessageType MessageType => MessageType.HealthCheck;\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"workflowcancelledmessage",children:"WorkflowCancelledMessage"}),"\n",(0,r.jsxs)(n.p,{children:["Published when a workflow is cancelled. The reason why the job was cancelled is indicated in the ",(0,r.jsx)(n.code,{children:"ErrorCode"})," property."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class WorkflowCancelledMessage : WorkflowMessage \n{\n    public MessageType MessageType => MessageType.WorkflowCancelled;\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"workflowcompletedmessage",children:"WorkflowCompletedMessage"}),"\n",(0,r.jsx)(n.p,{children:"Published at the end of the personalization process. This message indicates that the card was successfully produced and was moved\nto the output stacker"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class WorkflowCompletedMessage : WorkflowMessage \n{\n    public MessageType MessageType => MessageType.WorkflowCompleted;\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"workflowfaultedmessage",children:"WorkflowFaultedMessage"}),"\n",(0,r.jsxs)(n.p,{children:["Published if an error occurred during the production process or any of the external processes returned ",(0,r.jsx)(n.code,{children:"Outcome = Faulted"}),".\nThe ",(0,r.jsx)(n.code,{children:"ErrorCode"})," property contains the reason of the fault."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class WorkflowFaultedMessage : WorkflowMessage \n{\n    public MessageType MessageType => MessageType.WorkflowFaulted;\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"workflowschedulerstartedmessage",children:"WorkflowSchedulerStartedMessage"}),"\n",(0,r.jsx)(n.p,{children:"Sent when AIDA starts polling the database for records"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class WorkflowSchedulerStartedMessage : WorkflowMessage \n{\n    public MessageType MessageType => MessageType.WorkflowSchedulerStarted;\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"workflowschedulerstoppedmessage",children:"WorkflowSchedulerStoppedMessage"}),"\n",(0,r.jsx)(n.p,{children:"Sent when all running jobs finished executing. This message is necessary because issuance can be stopped in 2 modalities"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Graceful stop"})," - AIDA stops processing records from the DB and finish all the processes that are already executing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Abort"})," - AIDA stops processing records from the DB, aborts all running operations, cancels all running jobs which will result in cards being rejected."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class WorkflowSchedulerStoppedMessage : WorkflowMessage\n{\n    public WorkflowSchedulerStopReason StopReason;\n}\n\npublic enum WorkflowSchedulerStopReason\n{\n    // The scheduler finished processing all the cards in a batch\n    BatchCompleted,\n    // The StopWorkflowScheduler endpoint was invoked \n    // while issuance was suspended with `FeederEmpty` error code\n    FeederEmpty,\n    // The StopWorkflowScheduler endpoint was invoked to stop issuance \n    ManualStop,\n    // A card got stuck in the machine's transport \n    // and was not possible to recover\n    CardJam,\n    // An uncaught exception killed a job\n    UnhandledException,\n    // The webhooks receiver is unreachable\n    WebhooksServerUnreachable,\n    // The data source configuration for the selected job template is invalid\n    InvalidDataSourceConfiguration,\n    // AIDA was not able to reset the transport when starting issuance\n    TransportResetFailed\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"externalprocesscompletedmessage",children:"ExternalProcessCompletedMessage"}),"\n",(0,r.jsxs)(n.p,{children:["This is the payload that ",(0,r.jsx)(n.code,{children:"Webhook Receivers"})," must send when invoking the ",(0,r.jsx)(n.code,{children:"SignalExternalProcessCompleted"})," endpoint. Only 2 properties are required and they are:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"WorkflowInstanceId"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"Outcome"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["AIDA includes the ",(0,r.jsx)(n.code,{children:"WorkflowInstanceId"})," in all webhook messages. ",(0,r.jsx)(n.code,{children:"Outcome"})," is required and tells AIDA if the external process succeeded or not.\nset it to ",(0,r.jsx)(n.code,{children:"Completed"})," if the operation succeeds, ",(0,r.jsx)(n.code,{children:"Faulted"})," otherwise."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class ExternalProcessCompletedMessage\n{\n    // Optional. If present it is stored in the Data Exchange Table. Can be used\n    // to store error descriptions when the external process fails\n    public string? ErrorReason { get; set; }\n\n    // It must contain the same value sent by AIDA in webhook messages. \n    public string WorkflowInstanceId { get; set; }\n\n    // Optional. Overrides the default behavior of AIDA when it handles\n    // The ExternalProcessCompletedMessage. \n    public WorkflowAction? RequiredAction { get; set; }\n    // The outcomeo of the external operation \n    public ExternalProcessOutcome Outcome { get; set; }\n}\n\n\n// The outcome of the external process execution result\npublic enum ExternalProcessOutcome\n{\n    // The external process succeeded\n    // The process resumes\n    Completed,\n    // The external process succeeded\n    // The card is rejected\n    Faulted,\n    // The external was cancelled\n    // The card is rejected\n    Canceled\n}\n\n\n// Used in ExternalProcessCompleted to override the default behavior\npublic enum WorkflowAction\n{\n    // Forces AIDA to reject the card\n    Reject,\n    // Forces AIDA to resume the process\n    Resume\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"sequence-diagrams-1",children:"Sequence Diagrams"}),"\n",(0,r.jsx)(n.p,{children:"Below you can find sequence diagrams that illustrate the Issuance startup sequence and the interations between AIDA\nand the webhook receiver during job execution."}),"\n",(0,r.jsx)(n.h4,{id:"issuance-startup-sequence",children:"Issuance Startup Sequence"}),"\n",(0,r.jsx)(n.mermaid,{value:"sequenceDiagram\n    autonumber\n\n    box Integration \n        participant c as Chip Perso Service\n        participant p as Perso Controller\n        participant w as Wehooks Receiver\n    end\n\n    box AIDA  \n        participant a as Aida REST API\n    end\n    \n    p ->>+  a : Start Issuance (StartWorkflowScheudler endpoint)\n\n    break CONFIG ERROR, issuance not started\n        a --\x3e p : Issuance status, stopped. Error code = Confiug Error\n    end\n\n    a --\x3e> p : 200 OK\n    note over a: Issuance Starting\n    \n    break Cant connect to Receiver \n        a --) p: Issunce not started\n    end\n    w --\x3e> a: 200 OK\n    a ->> w: Webhook | Scheduler Started\n\n    note over a: Issuance Started"}),"\n",(0,r.jsx)(n.h4,{id:"chip-encoding-sequence",children:"Chip Encoding Sequence"}),"\n",(0,r.jsx)(n.mermaid,{value:"sequenceDiagram \n    participant ec as Smartware Encoder\n\n    box Integration \n        participant c as Chip Perso Service\n        participant p as Perso Controller\n        participant w as Wehooks Receiver\n    end\n\n    box AIDA  \n        participant a as Aida REST API\n        participant j as Job\n    end\n    note over ec,a: At this point Issuance is running AIDA will poll the database for new jobs\n\n    loop Polling database for records in Waiting State\n        a --\x3e>+ j  : Start Job\n\n        j ->>   j: Load encoding station\n        j --\x3e>- a: Job suspended public errors\n\n        a ->>w  : Webhook | Encoder Loaded\n\n        break Webhooks Recever Unreachable\n            a ->>+j : Reject card\n            j --x-a : Card Rejectd        \n        end\n\n        w -) p : Enqueue Chip perso \n        w --\x3e> a : 200 OK \n        p --\x3e+ c : Handle Chip Perso\n        \n        c --\x3e+ ec : Connect\n        note left of ec: Integrations can access the device<br/>via TCP\n        ec --\x3e- c : Program Chip\n        c --\x3e>- p : Chip perso finished\n       \n       note over p,a: Notify AIDA when we finished\n\n       alt Chip Perso Succeeded\n        p ->> a : Notify Success\n        a --\x3e>p : 200 OK\n        a --\x3e+j : Resume\n        \n        note right of j: Continue With other Perso Operations\n\n        break If any perso operation fails\n            j --\x3e> a: Perso Failed\n            \n            a -) w:  Webhook | JobFaulted  \n            opt\n            w --\x3e w : Handle message\n            end\n            w --\x3e> a: 200 OK\n        end\n        \n        j --\x3e>- a: Perso Finished\n        a -) w : Webhook | Job Completed\n       else Chip Perso Failed\n            p ->> a : Notify Error\n            a --\x3e>p : 200 OK\n            a ->>+ j: Reject card \n\n            j --\x3e a: Card Rejected\n            a -x w: Webhook | Job Faulted\n            opt\n            w --\x3e w : Handle message\n            end\n            w --\x3e> a: 200 OK\n       end\n    end"}),"\n",(0,r.jsx)(n.h3,{id:"examples-3",children:"Examples"}),"\n",(0,r.jsx)(n.h4,{id:"handling-encoderloaded-message",children:"Handling EncoderLoaded Message"}),"\n",(0,r.jsx)(n.p,{children:"Once AIDA loads the encoding station it will send a request like the following"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-http",children:'POST /ixla/aida/v1/webhooks HTTP/1.1\nHost: webhooks-host:4567\nAccept: application/json\nContent-Type: application/json\n\n{\n    "messageType": "EncoderLoaded",\n    "workflowInstanceId": "19e37ccafbec489e843996aca2493eb9",\n    "encoderIndex": 0,\n    "encoderId": "encoder_cl_1", \n    "correlationId" : "00001"\n    "jobId": "40",\n    // ... more properties .. \n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"The fields that we really care about here are:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"messageType"}),". ",(0,r.jsx)(n.code,{children:"EncoderLoaded"})," means that AIDA placed a card in the encoding station"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"workflowInstanceId"}),", this field is populated by AIDA when the job execution starts, and it identifies the ",(0,r.jsx)(n.code,{children:"workflow"})," created to handle the card production"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"encoderIndex"}),". Tells us which encoder is holding the card"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"encoderName"}),". A name given to the encoder in AIDA Server's configuration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"correlationId"})," will contain the value of the ",(0,r.jsx)(n.code,{children:"correlation_id"})," field from the ",(0,r.jsx)(n.code,{children:"Data Exchange Table"})," if provided"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"jobId"})," a unique identifier for the ",(0,r.jsx)(n.code,{children:"Job"})," (auto generated by AIDA)."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["You may notice we have 2 identifiers for the ",(0,r.jsx)(n.code,{children:"Job"}),". The difference between the 2 is that ",(0,r.jsx)(n.code,{children:"jobId"})," is the ",(0,r.jsx)(n.code,{children:"primary key"})," for the record in the ",(0,r.jsx)(n.code,{children:"Data Exchange Table"})," while the ",(0,r.jsx)(n.code,{children:"WorkflowInstanceId"})," is populated by the internal workflow engine as soon as AIDA starts processing the record."]}),"\n",(0,r.jsxs)(n.p,{children:["If we are able to parse the request payload, we need to send the ",(0,r.jsx)(n.code,{children:"HTTP Response"}),", otherwise the ",(0,r.jsx)(n.code,{children:"HTTP POST"})," request on the other end will timeout"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-http",children:"HTTP/1.1 200 OK \n...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["At this point we can do whatever we want with the card. Once we finish we can use the ",(0,r.jsx)(n.em,{children:"SignalExternalProcessCompleted"})," API endpoint to either resume the process and continue with other operations or reject the card."]}),"\n",(0,r.jsx)(n.h5,{id:"resuming--rejecting",children:"Resuming / Rejecting"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-http",children:'POST /aida/v1/workfllow-scheduler/signal/external-process-completed HTTP/1.1\nHost: machine-ip-address:5000\nAccept: application/json\nContent-Type: application/json\n\n{\n    "outcome": "Completed",\n    "workflowInstance": "19e37ccafbec489e843996aca2493eb9" \n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Here we tell AIDA that we did not ran into problems (",(0,r.jsx)(n.code,{children:"Completed"})," outcome) and it can resume the workflow instance (aka the ",(0,r.jsx)(n.code,{children:"Job"}),") with id ",(0,r.jsx)(n.code,{children:"19e37ccafbec489e843996aca2493eb9"}),"  (we received in the ",(0,r.jsx)(n.code,{children:"EncoderLoaded"})," webhook message)."]}),"\n",(0,r.jsxs)(n.p,{children:["If we instead want to reject the card, we simply return the ",(0,r.jsx)(n.code,{children:"Faulted"})," outcome:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-http",children:'POST /aida/v1/workfllow-scheduler/workflows/signal/external-process-completed HTTP/1.1\nHost: machine-ip-address:5000\nAccept: application/json\nContent-Type: application/json\n\n{\n    "outcome": "Faulted",\n    "workflowInstance": "19e37ccafbec489e843996aca2493eb9" \n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"handling-schedulerprocesssuspended-message",children:"Handling SchedulerProcessSuspended Message"}),"\n",(0,r.jsxs)(n.p,{children:["In the case of recoverable errors, AIDA suspends issuance and publishes the ",(0,r.jsx)(n.code,{children:"WorfklowSchedulerProcessSuspendedMessage"}),". Possible error codes are:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"FeederEmpty"})," - The input feeder has no cards"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"OpenInterlock"})," - Open interlocks detected"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"CardJam"})," - Recoverable only in ",(0,r.jsx)(n.em,{children:"BOX"})," systems"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The controlling application can decide which is the correct behavior in this case.\nIt could notify the operator about the error, and then invoke the ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"ResumeWorkflowScheduler"})})," endpoint or stop issuance ",(0,r.jsx)(n.em,{children:"Gracefuly"})," invoking the ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"StopWorkflowScheduler"})})," endpoint."]}),"\n",(0,r.jsx)(n.h5,{id:"feeder-empty-example",children:"Feeder empty example"}),"\n",(0,r.jsxs)(n.p,{children:["In this example we will see how to handle the ",(0,r.jsx)(n.code,{children:"FeederEmpty"})," erorr code, but the same concept applies to other recoverable errors like ",(0,r.jsx)(n.code,{children:"OpenInterlock"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If the input feeder is empty when AIDA is trying to start a new job, it will publish the ",(0,r.jsx)(n.code,{children:"WorkflowSchedulerProcessSuspendedMessage"}),", which looks like this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-http",children:'POST /ixla/aida/v1/webhooks HTTP/1.1\nHost: webhooks-host:4567\nContent-Type: application/json\n\n{\n    "MessageType": "WorkflowSchedulerStopped",\n    "ErrorCode": "FeederEmpty",\n    // ... more properties ... \n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In this case we can load the input feeder with cards, then tell AIDA to retry by invoking the ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"ResumeWorkflowScheduler"})})," endpoint."]}),"\n",(0,r.jsx)(n.h5,{id:"resuming-suspended-workflows",children:"Resuming suspended workflows"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-http",children:"POST /aida/v1/workflow-scheduler/resume HTTP/1.1\nHost: machine-ip-address:5000\nAccept: application/json\nContent-Type: application/json\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This endpoint does not require the ",(0,r.jsx)(n.code,{children:"workflowInstanceId"})," parameter because it will try to resume ",(0,r.jsx)(n.em,{children:"ALL suspended workflows in a recoverable error state"}),". In this case order is preserved by the system."]}),"\n",(0,r.jsx)(n.p,{children:"When resuming, AIDA will try to execute the last activity that caused the process to suspend. If it encounters the same error condition, it will simply suspend workflows again and repeat the process."}),"\n",(0,r.jsx)(n.h5,{id:"graceful-stop",children:"Graceful stop"}),"\n",(0,r.jsxs)(n.p,{children:["Lets suppose we don't want to recover from the ",(0,r.jsx)(n.code,{children:"FeederEmpty"})," state, instead we want the machine to finish whatever it was doing and stop. To do this, we can instruct it to stop ",(0,r.jsx)(n.em,{children:"gracefully"})," by invoking the ",(0,r.jsx)(n.code,{children:"StopWorkflowScheduler"})," endpoint with the ",(0,r.jsx)(n.code,{children:"stopRunningWorkflows"})," parameter set to ",(0,r.jsx)(n.code,{children:"false"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-http",children:"POST /aida/v1/workflow-scheduler/stop?stopRunningWorkflows=false HTTP/1.1\nHost: aida-machine-address:5000\nAccept: application/json\nContent-Type: application/json\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The system will enter the ",(0,r.jsx)(n.code,{children:"Stopping"})," state, finish the jobs it was running. When all jobs complete it will publish the ",(0,r.jsx)(n.code,{children:"WorkflowSchedulerStopped"})," endpoint with ",(0,r.jsx)(n.a,{href:"#workflowschedulerstoppedmessage",children:"WorkflowSchedulerStopReason"})," set to ",(0,r.jsx)(n.code,{children:"ManualStop"})]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);